# 正则表达式总结（RegExp）

**var expression = /patten/flag;**

## flag:

**g**:表示全局模式；应用于所有字符串；
**i**:表示不区分大小；匹配第一个匹配到的字符串；
**m**：表示多行匹配模式；
匹配任意字符：.     **/.at/i**   表示匹配到第一个以at结尾的三字符串，
匹配字母和数字： **\w**      \W:匹配\w的补集；
匹配数字：**\d**            \D:匹配\d的补集；
匹配空白字符串：**\s**       \S:匹配\d的补集；
字符集合**[a-zA-Z0-9]**   括号内算一个字符：表字符出现的可能性，范围；匹配汉字可以用unicode匹配 \u4e00 - \u9fa5
脱字符**^**：排除某个字符集，即表示不匹配这组字符中的任何字符
重复一次或多次： **+**   
出现0次或一次； *****
重复0个或多个：**？**
指定重复次数：**{1,4}**重复1次到4次；  **{2}**重复2次  **\b**表示边界；{1,4}\b
分组和替换：**()** 组号$1，$2...
**(?:模式)**匹配分组但不捕获；有分组，但不捕获，没有编号$1
**(?=模式)**正向肯定预查：必须有但不匹配；要匹配的东西后边有什么 
**(?!模式)**正向否定预查：用时必须包括前面匹配的字符；/\d+(?!元|\d)/g
**(?<=模式)**反向肯定预查：必须有但不匹配；要匹配的东西前边有什么 

### 转义字符

**(元字符必须转义)：( ) { } \ [ ] ^ * $ | ? . +** 
**写法**： let pat=/[bc]at/i;     // let pat = new RegExp('[bc]at',i);
注：由于RegExp构造函数的模式参数是字符串，在遇到表达元字符串时要进行双重转义；
    eg:/\[bc\]at/    //   "\\[bc\\]at"

#### **属性**：

lastIndex：整数，表示开始搜索下一个匹配项的字符串的字符位置；

#### 方法：

**.exec(str)**     //return arr ：null//   
    str:要进行匹配的字符串；
    返回一个数组的实例，有两个特殊的属性：index;表示匹配项在字符串中的位；input：表示应用正则表达式的字符串；数组第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果没有捕获组则只有一项），例子看参考小红书P106；

**.test(str)**      //return true :false//
    接受一个字符串返回布尔值，表示在模式与在参数匹配的情况下返回true
    可以用来检查匹配项是否在目标字符串中是否匹配，常用在if语句中；

#### RegExp构造函数属性：

长属性名        短属性名    		说明
.input          		$_      	  最近一次要匹配的字符串
.lastMatch     	 $&       	最近一次的匹配项
.lastParen      	 $+       	最近一次匹配的捕获组
.leftContext   	 $`      	 input字符串中lastMatch之前的文本
.rightContext  	$'     	   input字符串中lastMatch之后的文本
.multiline      	   $*      	布尔值，表示是否所有表达式都使用多行模式；





